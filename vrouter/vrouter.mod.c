#include <linux/module.h>
#include <linux/vermagic.h>
#include <linux/compiler.h>

MODULE_INFO(vermagic, VERMAGIC_STRING);

__visible struct module __this_module
__attribute__((section(".gnu.linkonce.this_module"))) = {
	.name = KBUILD_MODNAME,
	.init = init_module,
#ifdef CONFIG_MODULE_UNLOAD
	.exit = cleanup_module,
#endif
	.arch = MODULE_ARCH_INIT,
};

static const struct modversion_info ____versions[]
__used
__attribute__((section("__versions"))) = {
	{ 0xbff2abe1, __VMLINUX_SYMBOL_STR(module_layout) },
	{ 0x100932db, __VMLINUX_SYMBOL_STR(register_netdevice) },
	{ 0x609f1c7e, __VMLINUX_SYMBOL_STR(synchronize_net) },
	{ 0x2761b692, __VMLINUX_SYMBOL_STR(cpu_sibling_map) },
	{ 0xb995fbd9, __VMLINUX_SYMBOL_STR(cdev_alloc) },
	{ 0x2d3385d3, __VMLINUX_SYMBOL_STR(system_wq) },
	{ 0xafd02d98, __VMLINUX_SYMBOL_STR(cdev_del) },
	{ 0x74cf6b1f, __VMLINUX_SYMBOL_STR(kmalloc_caches) },
	{ 0xd2b09ce5, __VMLINUX_SYMBOL_STR(__kmalloc) },
	{ 0x51635c28, __VMLINUX_SYMBOL_STR(cdev_init) },
	{ 0xf9a482f9, __VMLINUX_SYMBOL_STR(msleep) },
	{ 0xe6fb675c, __VMLINUX_SYMBOL_STR(node_to_cpumask_map) },
	{ 0xdcb36a4b, __VMLINUX_SYMBOL_STR(__skb_gso_segment) },
	{ 0xd220cf8a, __VMLINUX_SYMBOL_STR(jiffies_to_timespec) },
	{ 0xb6b46a7c, __VMLINUX_SYMBOL_STR(param_ops_int) },
	{ 0x754d539c, __VMLINUX_SYMBOL_STR(strlen) },
	{ 0x60a13e90, __VMLINUX_SYMBOL_STR(rcu_barrier) },
	{ 0x43a53735, __VMLINUX_SYMBOL_STR(__alloc_workqueue_key) },
	{ 0x3a691dce, __VMLINUX_SYMBOL_STR(genl_unregister_family) },
	{ 0x79aa04a2, __VMLINUX_SYMBOL_STR(get_random_bytes) },
	{ 0x4f380774, __VMLINUX_SYMBOL_STR(napi_complete) },
	{ 0xd067fc5c, __VMLINUX_SYMBOL_STR(proc_dointvec) },
	{ 0x96157343, __VMLINUX_SYMBOL_STR(netdev_rx_handler_register) },
	{ 0xc715d9e0, __VMLINUX_SYMBOL_STR(boot_cpu_data) },
	{ 0xc7a4fbed, __VMLINUX_SYMBOL_STR(rtnl_lock) },
	{ 0x1637ff0f, __VMLINUX_SYMBOL_STR(_raw_spin_lock_bh) },
	{ 0x19d66ca2, __VMLINUX_SYMBOL_STR(skb_clone) },
	{ 0xc0a3d105, __VMLINUX_SYMBOL_STR(find_next_bit) },
	{ 0xd2da1048, __VMLINUX_SYMBOL_STR(register_netdevice_notifier) },
	{ 0x88bfa7e, __VMLINUX_SYMBOL_STR(cancel_work_sync) },
	{ 0x95d2d5f2, __VMLINUX_SYMBOL_STR(inet_proto_csum_replace4) },
	{ 0x593a99b, __VMLINUX_SYMBOL_STR(init_timer_key) },
	{ 0x73f2513e, __VMLINUX_SYMBOL_STR(__genl_register_family) },
	{ 0x7485e15e, __VMLINUX_SYMBOL_STR(unregister_chrdev_region) },
	{ 0x4629334c, __VMLINUX_SYMBOL_STR(__preempt_count) },
	{ 0x54efb5d6, __VMLINUX_SYMBOL_STR(cpu_number) },
	{ 0xef2843eb, __VMLINUX_SYMBOL_STR(skb_partial_csum_set) },
	{ 0x844a9b80, __VMLINUX_SYMBOL_STR(netif_napi_del) },
	{ 0x7d11c268, __VMLINUX_SYMBOL_STR(jiffies) },
	{ 0x9d0d6206, __VMLINUX_SYMBOL_STR(unregister_netdevice_notifier) },
	{ 0xe2d5255a, __VMLINUX_SYMBOL_STR(strcmp) },
	{ 0x27c33efe, __VMLINUX_SYMBOL_STR(csum_ipv6_magic) },
	{ 0x74ee7c33, __VMLINUX_SYMBOL_STR(netif_rx) },
	{ 0xc21446f3, __VMLINUX_SYMBOL_STR(__pskb_pull_tail) },
	{ 0xfe7c4287, __VMLINUX_SYMBOL_STR(nr_cpu_ids) },
	{ 0xd5f2172f, __VMLINUX_SYMBOL_STR(del_timer_sync) },
	{ 0x7249737a, __VMLINUX_SYMBOL_STR(skb_queue_purge) },
	{ 0xfb578fc5, __VMLINUX_SYMBOL_STR(memset) },
	{ 0x27e1a049, __VMLINUX_SYMBOL_STR(printk) },
	{ 0xfc24da9c, __VMLINUX_SYMBOL_STR(ethtool_op_get_link) },
	{ 0x449ad0a7, __VMLINUX_SYMBOL_STR(memcmp) },
	{ 0x4c9d28b0, __VMLINUX_SYMBOL_STR(phys_base) },
	{ 0xd8b0c2c8, __VMLINUX_SYMBOL_STR(__ethtool_get_settings) },
	{ 0x660b4d61, __VMLINUX_SYMBOL_STR(free_netdev) },
	{ 0xa1c76e0a, __VMLINUX_SYMBOL_STR(_cond_resched) },
	{ 0x9166fada, __VMLINUX_SYMBOL_STR(strncpy) },
	{ 0xbbc0fa75, __VMLINUX_SYMBOL_STR(netif_receive_skb) },
	{ 0x5a921311, __VMLINUX_SYMBOL_STR(strncmp) },
	{ 0xbf8ba54a, __VMLINUX_SYMBOL_STR(vprintk) },
	{ 0x16305289, __VMLINUX_SYMBOL_STR(warn_slowpath_null) },
	{ 0xadabfe16, __VMLINUX_SYMBOL_STR(skb_push) },
	{ 0x8c03d20c, __VMLINUX_SYMBOL_STR(destroy_workqueue) },
	{ 0x341cbed2, __VMLINUX_SYMBOL_STR(cpu_present_mask) },
	{ 0xf77ee28b, __VMLINUX_SYMBOL_STR(dev_get_by_index) },
	{ 0x8834396c, __VMLINUX_SYMBOL_STR(mod_timer) },
	{ 0x4afbf0ec, __VMLINUX_SYMBOL_STR(netlink_unicast) },
	{ 0x1aaa1b1e, __VMLINUX_SYMBOL_STR(netif_napi_add) },
	{ 0xbe2c0274, __VMLINUX_SYMBOL_STR(add_timer) },
	{ 0xe7e8b5, __VMLINUX_SYMBOL_STR(skb_pull) },
	{ 0x8a1372cf, __VMLINUX_SYMBOL_STR(init_net) },
	{ 0x7c88f3ae, __VMLINUX_SYMBOL_STR(__skb_get_hash) },
	{ 0x122fc387, __VMLINUX_SYMBOL_STR(rtnl_link_unregister) },
	{ 0x5e8a8764, __VMLINUX_SYMBOL_STR(__get_page_tail) },
	{ 0x42160169, __VMLINUX_SYMBOL_STR(flush_workqueue) },
	{ 0x9f46ced8, __VMLINUX_SYMBOL_STR(__sw_hweight64) },
	{ 0x5d595775, __VMLINUX_SYMBOL_STR(cdev_add) },
	{ 0xc3e06579, __VMLINUX_SYMBOL_STR(skb_queue_tail) },
	{ 0x3ff62317, __VMLINUX_SYMBOL_STR(local_bh_disable) },
	{ 0x92562c79, __VMLINUX_SYMBOL_STR(napi_gro_receive) },
	{ 0x618911fc, __VMLINUX_SYMBOL_STR(numa_node) },
	{ 0x3d6a93ef, __VMLINUX_SYMBOL_STR(__alloc_skb) },
	{ 0xa4a5004a, __VMLINUX_SYMBOL_STR(__napi_schedule) },
	{ 0x93fca811, __VMLINUX_SYMBOL_STR(__get_free_pages) },
	{ 0xac3d20e2, __VMLINUX_SYMBOL_STR(unregister_sysctl_table) },
	{ 0xba63339c, __VMLINUX_SYMBOL_STR(_raw_spin_unlock_bh) },
	{ 0xf0fdf6cb, __VMLINUX_SYMBOL_STR(__stack_chk_fail) },
	{ 0xb4321e88, __VMLINUX_SYMBOL_STR(netdev_rx_handler_unregister) },
	{ 0x38f97cc7, __VMLINUX_SYMBOL_STR(skb_checksum_help) },
	{ 0x3bd1b1f6, __VMLINUX_SYMBOL_STR(msecs_to_jiffies) },
	{ 0x9e9f1714, __VMLINUX_SYMBOL_STR(__bitmap_andnot) },
	{ 0x91ddcdc7, __VMLINUX_SYMBOL_STR(kfree_skb) },
	{ 0x7547b0dc, __VMLINUX_SYMBOL_STR(alloc_netdev_mqs) },
	{ 0x799aca4, __VMLINUX_SYMBOL_STR(local_bh_enable) },
	{ 0x987d6d58, __VMLINUX_SYMBOL_STR(eth_type_trans) },
	{ 0xec83b465, __VMLINUX_SYMBOL_STR(dev_driver_string) },
	{ 0xbe156a65, __VMLINUX_SYMBOL_STR(pskb_expand_head) },
	{ 0xbdfb6dbb, __VMLINUX_SYMBOL_STR(__fentry__) },
	{ 0x6915f605, __VMLINUX_SYMBOL_STR(ether_setup) },
	{ 0xdf3deb56, __VMLINUX_SYMBOL_STR(kmem_cache_alloc_trace) },
	{ 0x3928efe9, __VMLINUX_SYMBOL_STR(__per_cpu_offset) },
	{ 0x870285f5, __VMLINUX_SYMBOL_STR(unregister_netdevice_queue) },
	{ 0x4302d0eb, __VMLINUX_SYMBOL_STR(free_pages) },
	{ 0x4f68e5c9, __VMLINUX_SYMBOL_STR(do_gettimeofday) },
	{ 0x37a0cba, __VMLINUX_SYMBOL_STR(kfree) },
	{ 0x69acdf38, __VMLINUX_SYMBOL_STR(memcpy) },
	{ 0x801678, __VMLINUX_SYMBOL_STR(flush_scheduled_work) },
	{ 0xa75312bc, __VMLINUX_SYMBOL_STR(call_rcu_sched) },
	{ 0x89ebca73, __VMLINUX_SYMBOL_STR(rtnl_link_register) },
	{ 0x5c7cf16, __VMLINUX_SYMBOL_STR(skb_segment) },
	{ 0x4cbbd171, __VMLINUX_SYMBOL_STR(__bitmap_weight) },
	{ 0x5115c39, __VMLINUX_SYMBOL_STR(skb_dequeue) },
	{ 0x76d25fd0, __VMLINUX_SYMBOL_STR(unregister_netdev) },
	{ 0x2e0d2f7f, __VMLINUX_SYMBOL_STR(queue_work_on) },
	{ 0xb0e602eb, __VMLINUX_SYMBOL_STR(memmove) },
	{ 0xe113bbbc, __VMLINUX_SYMBOL_STR(csum_partial) },
	{ 0xefee5d53, __VMLINUX_SYMBOL_STR(consume_skb) },
	{ 0xd982ac21, __VMLINUX_SYMBOL_STR(dev_queue_xmit) },
	{ 0x47c8baf4, __VMLINUX_SYMBOL_STR(param_ops_uint) },
	{ 0x9b28d8b6, __VMLINUX_SYMBOL_STR(skb_copy_bits) },
	{ 0xecd194c6, __VMLINUX_SYMBOL_STR(__nlmsg_put) },
	{ 0xf33fc451, __VMLINUX_SYMBOL_STR(netif_skb_dev_features) },
	{ 0x6e720ff2, __VMLINUX_SYMBOL_STR(rtnl_unlock) },
	{ 0x29537c9e, __VMLINUX_SYMBOL_STR(alloc_chrdev_region) },
	{ 0x7c2d098f, __VMLINUX_SYMBOL_STR(krealloc) },
	{ 0x8fe48b08, __VMLINUX_SYMBOL_STR(register_sysctl_paths) },
	{ 0xf37f5e99, __VMLINUX_SYMBOL_STR(__skb_checksum_complete) },
};

static const char __module_depends[]
__used
__attribute__((section(".modinfo"))) =
"depends=";


MODULE_INFO(srcversion, "F682B1C96FA0E9889F928AF");
